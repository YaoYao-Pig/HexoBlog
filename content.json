{"posts":[{"title":"","text":"GC用的是可达性分析+压缩+分代的处理方法 这里说下压缩： 在一次GC结束之后，会有很多不可达的对象被回收了。这样的话这些对象所处的内存占用就不连续了，C#GC的时候会先停掉所有的线程，防止在GC的时候线程再修改。 然后GC会把回收后剩下的对象移动位置，让他们在托管堆上连续。然后重新修改对象中引用其他对象的偏移量（因为被移动压缩了）","link":"/HexoBlog/2025/05/16/C#/C#GC/"},{"title":"Index","text":"欢迎来到我的博客！博客展现的可能比较乱，最好看我的Github的笔记仓库: https://github.com/YaoYao-Pig/YaoYaoPigStudyNote 博客分类： 帧同步：一个帧同步框架的设计 我正在搭建自己的帧同步框架：https://github.com/YaoYao-Pig/SimpleLockStepFrameWork 计算机图形学：图形学学习 C#：C#相关内容的学习 C++：C++相关内容学习 Lua：Lua相关内容学习 Paper/PaperReading：论文阅读的笔记 Unity：引擎相关 面经：面经整理","link":"/HexoBlog/2025/12/31/Index/"},{"title":"","text":"https://www.bilibili.com/video/BV1P84y1T74w/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5d4070cc138983fa1babce80b5a31622 特性就是一个继承自Attribute的类 然后再反射的时候使用获取他，才有效果（就是一个元数据的标记）","link":"/HexoBlog/2025/05/16/C#/C#%E5%8F%8D%E5%B0%84%E5%92%8C%E7%89%B9%E6%80%A7/"},{"title":"","text":"第四章 类型类型转换C#动态类型转换的时候，如果是向基类转换，可以直接隐式转换 但是如果是向子类，那就必须显式转换。这时候，转换的时候就会检查是否能转换。如果不能抛出异常。 C#的 as和C++ dynamic_cast是差不多的，都是转换的时候会检查能不能转换，如果不能返回null，比先is再转换效率高 C++dynamic_cast的时候，会查看存储在虚函数表的type_info，对于向下转换，如果一个Base* b的实际动态类型是一个Base，那么他type_info里存储的类型和Derived就不一样，那么就会报错。 本质上就是利用动态类型做类型检查是否匹配 type 每个类型都会对应一个类型对象，在执行程序前，CLR会保证这些类型对象被成功加载并且管理起来。他们其实都是一个Type类型对象的实例 每个 类型 都会在堆上有一个对应的 类型对象。在 C# 中，类型对象是通过 Type 类表示的，它是一个运行时的元数据对象，描述了某个类型的结构和特性。每个类型（类、接口、枚举等）在运行时都有一个 Type 实例，它用于反射、类型检查、动态创建对象等操作。 不过，需要澄清的是，类型对象本身并不是一个普通的类实例，它并不像普通的类对象那样存储在堆上，而是作为 CLR（公共语言运行时）的一部分存在并管理。 类型对象是 CLR 管理的元数据，通常不会像普通对象那样被回收。CLR 会在应用程序生命周期内保持这些类型对象的存在，直到程序退出或进程终止。 每个类型都会有一个与之关联的 Type 对象。这个 Type 对象本身也是一个类型实例，可以通过 typeof 关键字或者对象的 GetType() 方法来获取。 示例：使用 typeof 获取类型对象123456789101112131415csharp复制代码using System;class MyClass{ public int MyProperty { get; set; }}class Program{ static void Main() { Type type = typeof(MyClass); // 获取 MyClass 类型的 Type 对象 Console.WriteLine(type.FullName); // 输出 MyClass 的全名 }} 第五值类型和引用类型值/引用类型的最终父类都是System.Object类，但是引用类型的直接继承自System.Object，值类型的直接父类是ValueType，而ValueType的父类是Object （意思是，C++当中，对象或者变量存在哪里是使用者决定的（比如分配在Stack和new Class分配在堆上），而C#分配在哪里，是由于它是值类型还是引用类型） Boxing和UnBoxing有的时候，C#需要获取对象的地址，因此这时候就会发生拆箱装箱。而引用类型一直都是装箱状态，因此不会有这个问题。 其实，UnBoxing是获取指针的过程，而紧接着UnBoxing之后，还会发生一次字段的复制 这里有一个Trick，就是WriteLine的时候要用ToString，而不是直接把值类型传入WrtieLine。 因为WritLine要求传入String类型（引用类型）并且会调用Concat函数，Concat函数要求传入Object，而值类型这时候会发生装箱，但是用ToString就直接返回String类型了。 EqualObject.Equal的默认实现，实际上实现的是同一性的比较而不是相等性的比较，它会要求传入一个Object参数，比较二者的引用。但是并没有考虑内容 而IEquatable&lt;T&gt;接口要求实现的： 1234public interface IEquatable&lt;in T&gt;{ bool Equals(T other);} 则是一个类型安全的Equals，这里就要求我们自己设计一种相等性的比较 C#内部提供了检查同一性的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455//一个好的设计：using System;public class Person{ public string Name { get; set; } public int Age { get; set; } // 构造函数 public Person(string name, int age) { Name = name; Age = age; } // 重载 Equals 方法 public override bool Equals(object obj) { // 1. 检查是否是同一个引用 if (ReferenceEquals(this, obj)) return true; // 2. 如果 obj 为 null 或者类型不同，返回 false if (obj == null || this.GetType() != obj.GetType()) return false; // 3. 转换 obj 为 Person 类型并进行字段比较 Person other = (Person)obj; return this.Name == other.Name &amp;&amp; this.Age == other.Age; } // 重载 GetHashCode 方法，保证相等的对象具有相同的哈希码 public override int GetHashCode() { // 使用 Name 和 Age 生成哈希码 int hashName = Name == null ? 0 : Name.GetHashCode(); int hashAge = Age.GetHashCode(); return hashName ^ hashAge; // XOR 操作 }}class Program{ static void Main() { Person p1 = new Person(&quot;Alice&quot;, 30); Person p2 = new Person(&quot;Alice&quot;, 30); Person p3 = new Person(&quot;Bob&quot;, 25); // 比较 p1 和 p2（相等） Console.WriteLine(p1.Equals(p2)); // True // 比较 p1 和 p3（不相等） Console.WriteLine(p1.Equals(p3)); // False }} 3","link":"/HexoBlog/2025/05/16/C#/CLR%20via/"},{"title":"Lua与CSharp","text":"Lua与C#本质上，Lua与C#的交互都是依靠虚拟的托管堆进行的。 为了方便讨论，我们先对Lua和C#可能存在的交互行为进行分类： C#调用Lua代码，Lua调用C#代码 类 函数 静态函数 类内静态函数 类内非静态函数 C#调用Lua代码先定义什么叫做C#调用Lua代码：我们定义，从C#启动一段Lua的代码逻辑，叫做用C#调用Lua代码。 我们可以先思考一下在C#当中是如何使用XLua调用Lua代码的： 123LuaEnv luaEnv;string str = string.Format(&quot;require('{0}')&quot;, fileName);luaEnv.DoString(str); 我们先看LuaEnv是个什么，关注LuaEnv的构造函数 12// Create State】rawL = LuaAPI.luaL_newstate(); 大模型接口 爬虫Readme Readme里有网址，然后大模型对应的去找网址。 Discussions，问答对。 代理查ClickHouse对应项目的Issue+Pr Issue的提问，作为一个排除的方法，比如有的人想提issue，然后可以问是否有人提过了（本地查询然后提交类似Issue交给大模型判断） 喂给大模型做prompt工程 要做的事情： 选几个仓库作为demo演示的仓库 获取对应仓库的dissussion 获取对应仓库的Issue和状态 设计prompt和对应的功能 对项目的介绍（获取discussions） 提问issue的排除和查询","link":"/HexoBlog/2025/05/04/Lua/Lua%E4%B8%8EC#/"},{"title":"Lua的长度","text":"由于Lua的表并不是传统意义上的数组或者哈希表，因此Lua长度的意义其实并不明确。也是因此我们使用#符号的时候要很慎重 Lua的#符号的具体行为要看版本： 实际上Lua#返回的是：边界 什么是边界，Lua的定义是：对于一个表t，若t[i]~=nil and t[i+1] == nil 那么，这个i就是一个边界 任何一个版本的#，对于数组或者哈希表，找的都是：边界 5.2 这是我们从Github上拉取的v5.2版本的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758int luaH_getn (Table *t) { unsigned int j = t-&gt;sizearray; -- 二分查找数组部分的nil if (j &gt; 0 &amp;&amp; ttisnil(&amp;t-&gt;array[j - 1])) { /* there is a boundary in the array part: (binary) search for it */ unsigned int i = 0; while (j - i &gt; 1) { unsigned int m = (i+j)/2; if (ttisnil(&amp;t-&gt;array[m - 1])) j = m; else i = m; } return i; } /* else must find a boundary in hash part */ else if (isdummy(t-&gt;node)) /* hash part is empty? */ return j; /* that is easy... */ else return unbound_search(t, j);}-- 这个函数的作用是计算 Lua 表 t 的长度（对应 #t 操作符的结果）。它的实现分为以下几个步骤：-- 检查数组部分：-- j = t-&gt;sizearray：获取表的数组部分长度。-- 如果 j &gt; 0 且最后一个元素 t-&gt;array[j - 1] 为 nil，说明数组部分内部有空洞（即存在 nil）。-- 在这种情况下，使用二分查找在数组部分 [0, j) 中找到第一个 nil 出现的位置：-- 初始化 i = 0，j = t-&gt;sizearray。-- 每次取中间位置 m = (i + j) / 2。-- 如果 t-&gt;array[m - 1] 为 nil，说明边界在左侧，更新 j = m。-- 如果 t-&gt;array[m - 1] 非 nil，说明边界在右侧，更新 i = m。-- 最终返回 i，即最后一个非 nil 元素的索引加 1（也就是连续非 nil 元素的个数）。-- 处理哈希部分：-- 如果数组部分的最后一个元素非 nil（!ttisnil(&amp;t-&gt;array[j - 1])），或者数组部分为空（j == 0），则需要检查哈希部分。-- 如果哈希部分为空（isdummy(t-&gt;node)），直接返回数组部分的长度 j。-- 否则，调用 unbound_search(t, j) 在哈希部分中继续查找边界。-- 行为：从 t[1] 开始计算连续非 nil 元素的个数，遇到第一个 nil 就停止。 static int unbound_search (Table *t, unsigned int j) { unsigned int i = j; /* i is zero or a present index */ j++; /* find `i' and `j' such that i is present and j is not */ while (!ttisnil(luaH_getint(t, j))) { i = j; j *= 2; if (j &gt; cast(unsigned int, MAX_INT)) { /* overflow? */ /* table was built with bad purposes: resort to linear search */ i = 1; while (!ttisnil(luaH_getint(t, i))) i++; return i - 1; } } /* now do a binary search between them */ while (j - i &gt; 1) { unsigned int m = (i+j)/2; if (ttisnil(luaH_getint(t, m))) j = m; else i = m; } return i;}-- 数组的长度为 j，hash 部分从 j+1 开始遍历，j 每次扩大两倍，找到t[j] 不为空， t[2*j] 为空，然后通过二分法查找，找到最终的值。 5.2+ 检查数组部分 Lua 表有一个数组部分，用于存储从 1 开始的连续整数键，容量由 asize 表示。 如果 asize &gt; 0，说明表有数组部分，函数会优先处理这部分。 利用长度提示（hint） 表中有一个缓存的长度提示字段 lenhint，记录上次计算的长度。 初始时，limit = *lenhint(t)，如果 limit 为 0，则设为 1（因为 Lua 索引从 1 开始）。 根据 t[limit] 的状态查找边界 情况 1：t[limit] 为空（nil） 说明边界在 limit 之前。 附近查找：从 limit 向前最多检查 4 次（maxvicinity = 4），寻找一个位置 i，使得 t[i] 非 nil 且 t[i+1] 为 nil。若找到，返回 i 并更新提示。 二分查找：如果附近没找到，在 [0, limit) 范围内进行二分查找，找到边界并更新提示。 情况 2：t[limit] 非空 说明边界在 limit 之后。 附近查找：从 limit 向后最多检查 4 次，若 limit &lt; asize，寻找 t[i] 非 nil 且 t[i+1] 为 nil 的位置。若找到，返回 i 并更新提示。 进一步检查 ： 如果数组部分的最后一个元素 t[asize] 为空，则在 [limit, asize) 范围内进行二分查找，找到边界并更新提示。 如果 t[asize] 非空，说明数组部分没有边界，设置提示为 asize，并进入哈希部分的处理。 处理哈希部分 如果没有数组部分（asize == 0）或 t[asize] 非空，检查哈希部分。 情况分析 ： 如果表是“dummy”（空的或无哈希部分）或 t[asize + 1] 为空，返回 asize。 如果 t[asize + 1] 非空，调用 hash_search(t, asize) 在哈希部分中查找最大的 n &gt; asize，使得 t[n] 非 nil 且 t[n+1] 为 nil，并返回该值。 关键优化 提示机制：通过缓存长度提示，避免重复计算。 附近查找：在提示附近进行快速线性查找（最多 4 次），减少查找开销。 二分查找：当附近查找失败时，使用二分查找高效定位边界。 数组与哈希分离：优先处理数组部分，若必要再处理哈希部分，充分利用 Lua 表的结构特性。 总结luaH_getn 函数通过结合长度提示、附近线性查找和二分查找，高效地计算 Lua 表的“长度”。它首先尝试利用数组部分的连续性快速找到边界，若无法满足则在哈希部分继续查找。这种设计在表有大量连续整数键时性能优异，同时也能正确处理稀疏表或混合表的情况。最终返回的 lua_Unsigned 值反映了表的有效长度，适用于 Lua 的 # 操作符。 https://www.jianshu.com/p/1e8ab8fe55e4 这段代码是 Lua 中用于获取表（Table）数组部分有效长度的函数 luaH_getn 的实现。以下是代码的逐段解释： 1. 初始条件检查c 复制 下载 12unsigned int limit = t-&gt;alimit;if (limit &gt; 0 &amp;&amp; isempty(&amp;t-&gt;array[limit - 1])) { 目的：检查数组部分的“逻辑边界”是否需要调整。 alimit 是表的预分配数组大小，但可能不反映实际的有效元素边界。 如果 alimit-1 位置的元素为空（isempty），说明当前 alimit 可能不是有效边界，需要进一步处理。 2. 快速调整边界c 复制 下载 1234567if (limit &gt;= 2 &amp;&amp; !isempty(&amp;t-&gt;array[limit - 2])) { if (ispow2realasize(t) &amp;&amp; !ispow2(limit - 1)) { t-&gt;alimit = limit - 1; setnorealasize(t); } return limit - 1;} 场景：如果 limit-2 位置非空，且 limit-1 为空，说明 limit-1 是有效边界。 优化：如果表的真实数组大小是 2 的幂（ispow2realasize），但 limit-1 不是 2 的幂，则将 alimit 设为 limit-1，并标记真实大小不再等于 alimit（setnorealasize）。 返回：直接返回 limit-1 作为有效边界。 3. 二分查找边界c 复制 下载 12345678else { unsigned int boundary = binsearch(t-&gt;array, 0, limit); if (ispow2realasize(t) &amp;&amp; boundary &gt; luaH_realasize(t) / 2) { t-&gt;alimit = boundary; setnorealasize(t); } return boundary;} 场景：当无法快速确定边界时，在 [0, limit] 范围内通过二分查找 (binsearch) 找到第一个空元素的位置作为边界。 优化：如果真实数组大小是 2 的幂，且找到的边界超过其一半，更新 alimit 为这个边界，以提高后续操作效率。 4. 处理未调整的 alimitc 复制 下载 123456789if (!limitequalsasize(t)) { if (isempty(&amp;t-&gt;array[limit])) return limit; limit = luaH_realasize(t); if (isempty(&amp;t-&gt;array[limit - 1])) { unsigned int boundary = binsearch(t-&gt;array, t-&gt;alimit, limit); t-&gt;alimit = boundary; return boundary; }} 场景：如果 alimit 不等于真实数组大小（limitequalsasize），说明数组有更多元素。 检查空洞： 如果 array[limit] 为空，直接返回 limit 作为边界。 否则，将 limit 设为真实数组大小，继续检查末尾是否为空。 如果末尾为空，通过二分查找调整 alimit。 5. 处理哈希部分的影响c 复制 下载 123456lua_assert(limit == luaH_realasize(t) &amp;&amp; (limit == 0 || !isempty(&amp;t-&gt;array[limit - 1])));if (isdummy(t) || isempty(luaH_getint(t, cast(lua_Integer, limit + 1)))) return limit;else return hash_search(t, limit); 断言：确保 limit 是真实数组大小，且末尾元素非空。 哈希检查： 如果表是虚拟表（isdummy）或 limit+1 在哈希部分为空，返回 limit。 否则，调用 hash_search 在哈希部分中查找可能的连续键（如 limit+1），扩展有效长度。 总结 核心逻辑：通过数组部分的预分配大小 (alimit)、二分查找和哈希部分的检查，高效确定表的有效长度。 优化点：维护 alimit 为 2 的幂以提高内存分配效率，动态调整逻辑边界。 典型用例：Lua 中 # 运算符获取数组长度时调用此函数，正确处理数组空洞和哈希部分。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/*** Try to find a boundary in table 't'. (A 'boundary' is an integer index** such that t[i] is present and t[i+1] is absent, or 0 if t[1] is absent** and 'maxinteger' if t[maxinteger] is present.)** (In the next explanation, we use Lua indices, that is, with base 1.** The code itself uses base 0 when indexing the array part of the table.)** The code starts with 'limit = t-&gt;alimit', a position in the array** part that may be a boundary.**** (1) If 't[limit]' is empty, there must be a boundary before it.** As a common case (e.g., after 't[#t]=nil'), check whether 'limit-1'** is present. If so, it is a boundary. Otherwise, do a binary search** between 0 and limit to find a boundary. In both cases, try to** use this boundary as the new 'alimit', as a hint for the next call.**** (2) If 't[limit]' is not empty and the array has more elements** after 'limit', try to find a boundary there. Again, try first** the special case (which should be quite frequent) where 'limit+1'** is empty, so that 'limit' is a boundary. Otherwise, check the** last element of the array part. If it is empty, there must be a** boundary between the old limit (present) and the last element** (absent), which is found with a binary search. (This boundary always** can be a new limit.)**** (3) The last case is when there are no elements in the array part** (limit == 0) or its last element (the new limit) is present.** In this case, must check the hash part. If there is no hash part** or 'limit+1' is absent, 'limit' is a boundary. Otherwise, call** 'hash_search' to find a boundary in the hash part of the table.** (In those cases, the boundary is not inside the array part, and** therefore cannot be used as a new limit.)*/lua_Unsigned luaH_getn (Table *t) { unsigned int limit = t-&gt;alimit; if (limit &gt; 0 &amp;&amp; isempty(&amp;t-&gt;array[limit - 1])) { /* (1)? */ /* there must be a boundary before 'limit' */ if (limit &gt;= 2 &amp;&amp; !isempty(&amp;t-&gt;array[limit - 2])) { /* 'limit - 1' is a boundary; can it be a new limit? */ if (ispow2realasize(t) &amp;&amp; !ispow2(limit - 1)) { t-&gt;alimit = limit - 1; setnorealasize(t); /* now 'alimit' is not the real size */ } return limit - 1; } else { /* must search for a boundary in [0, limit] */ unsigned int boundary = binsearch(t-&gt;array, 0, limit); /* can this boundary represent the real size of the array? */ if (ispow2realasize(t) &amp;&amp; boundary &gt; luaH_realasize(t) / 2) { t-&gt;alimit = boundary; /* use it as the new limit */ setnorealasize(t); } return boundary; } } /* 'limit' is zero or present in table */ if (!limitequalsasize(t)) { /* (2)? */ /* 'limit' &gt; 0 and array has more elements after 'limit' */ if (isempty(&amp;t-&gt;array[limit])) /* 'limit + 1' is empty? */ return limit; /* this is the boundary */ /* else, try last element in the array */ limit = luaH_realasize(t); if (isempty(&amp;t-&gt;array[limit - 1])) { /* empty? */ /* there must be a boundary in the array after old limit, and it must be a valid new limit */ unsigned int boundary = binsearch(t-&gt;array, t-&gt;alimit, limit); t-&gt;alimit = boundary; return boundary; } /* else, new limit is present in the table; check the hash part */ } /* (3) 'limit' is the last element and either is zero or present in table */ lua_assert(limit == luaH_realasize(t) &amp;&amp; (limit == 0 || !isempty(&amp;t-&gt;array[limit - 1]))); if (isdummy(t) || isempty(luaH_getint(t, cast(lua_Integer, limit + 1)))) return limit; /* 'limit + 1' is absent */ else /* 'limit + 1' is also present */ return hash_search(t, limit);} /*** Try to find a boundary in the hash part of table 't'. From the** caller, we know that 'j' is zero or present and that 'j + 1' is** present. We want to find a larger key that is absent from the** table, so that we can do a binary search between the two keys to** find a boundary. We keep doubling 'j' until we get an absent index.** If the doubling would overflow, we try LUA_MAXINTEGER. If it is** absent, we are ready for the binary search. ('j', being max integer,** is larger or equal to 'i', but it cannot be equal because it is** absent while 'i' is present; so 'j &gt; i'.) Otherwise, 'j' is a** boundary. ('j + 1' cannot be a present integer key because it is** not a valid integer in Lua.)*/static lua_Unsigned hash_search (Table *t, lua_Unsigned j) { lua_Unsigned i; if (j == 0) j++; /* the caller ensures 'j + 1' is present */ do { i = j; /* 'i' is a present index */ if (j &lt;= l_castS2U(LUA_MAXINTEGER) / 2) j *= 2; else { j = LUA_MAXINTEGER; if (isempty(luaH_getint(t, j))) /* t[j] not present? */ break; /* 'j' now is an absent index */ else /* weird case */ return j; /* well, max integer is a boundary... */ } } while (!isempty(luaH_getint(t, j))); /* repeat until an absent t[j] */ /* i &lt; j &amp;&amp; t[i] present &amp;&amp; t[j] absent */ while (j - i &gt; 1u) { /* do a binary search between them */ lua_Unsigned m = (i + j) / 2; if (isempty(luaH_getint(t, m))) j = m; else i = m; } return i;} 以下是 Lua 5.1 和 Lua 5.2+ 版本 luaH_getn 的主要区别： 处理空洞（nil 值）的方式 ： Lua 5.1 ： 在数组部分，遇到第一个 nil 就停止，返回其之前的长度。 例如，对于表 t = {1, nil, 3}，luaH_getn 返回 1，因为 t[2] = nil 中断了连续性。 Lua 5.2+ ： 可以跳过中间的 nil，寻找最后一个非 nil 的整数键。 对于同样的表 t = {1, nil, 3}，返回 3，因为 t[3] 非 nil 且 t[4] 为 nil。 查找策略 ： Lua 5.1 ： 使用简单的二分查找，在数组部分找到第一个 nil 的位置。 没有长度提示，效率较低。 Lua 5.2+ ： 使用更复杂的查找策略，包括附近查找和二分查找，并利用长度提示优化性能。 对哈希部分的处理 ： Lua 5.1 ： 如果数组部分没有 nil，调用 unbound_search 在哈希部分查找边界，逻辑较为简单。 Lua 5.2+ ： 类似地在哈希部分查找，但实现上可能更复杂，支持跳过 nil 的逻辑。","link":"/HexoBlog/2025/05/04/Lua/Lua%E7%9A%84%E9%95%BF%E5%BA%A6/"},{"title":"XLua","text":"XLuahttps://zhuanlan.zhihu.com/p/441169478 https://www.cnblogs.com/iwiniwin/p/15307368.html https://www.bilibili.com/video/BV15N411S755/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5d4070cc138983fa1babce80b5a31622 https://zhuanlan.zhihu.com/p/571902078 https://blog.csdn.net/weixin_45218342/article/details/135899213 Lua弱引用https://cloud.tencent.com/developer/article/2317271 https://zhuanlan.zhihu.com/p/638008523 https://zhuanlan.zhihu.com/p/97322052 Lua访问C#代码Lua和C#通过一些API进行通信。对于基础数据类型，可以直接通过API通信。而对于那些C#自定义的类，C#会先把对象放进一个对象池，然后获得其对应的index。然后把index传递到Lua栈上，作为一个userdata。 Lua调用C#对象的函数，首先C#会生成一个胶合函数，注册到一个注册表里面，然后通过Lua栈获取调用的参数 CS其实是个表 然后定义了CS这个表的元表行为 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private string init_xlua = @&quot; local metatable = {} local rawget = rawget local setmetatable = setmetatable local import_type = xlua.import_type local import_generic_type = xlua.import_generic_type local load_assembly = xlua.load_assembly function metatable:__index(key) local fqn = rawget(self,'.fqn') fqn = ((fqn and fqn .. '.') or '') .. key --fqn就是类型和命名空间名,通过import_type去获取对应的udata并且入栈 local obj = import_type(fqn) if obj == nil then -- It might be an assembly, so we load it too. obj = { ['.fqn'] = fqn } setmetatable(obj, metatable) elseif obj == true then --从自身这个类的元表中获取key对应的值 return rawget(self, key) end -- Cache this lookup rawset(self, key, obj) return obj end function metatable:__newindex() error('No such type: ' .. rawget(self,'.fqn'), 2) end function metatable:__call(...) local n = select('#', ...) local fqn = rawget(self,'.fqn') if n &gt; 0 then local gt = import_generic_type(fqn, ...) if gt then return rawget(CS, gt) end end error('No such type: ' .. fqn, 2) end CS = CS or {} setmetatable(CS, metatable) typeof = function(t) return t.UnderlyingSystemType end //... 如果访问到了CS表中不存在的元素,则会调用其元表,在元表中通过映射到c#的StaticLuaCallbacks.ImportType方法完成查找 在XLua中，Lua栈确实可以存储C#函数，但并不直接存储C#函数本身，而是通过特定的机制将C#函数封装成Lua可执行的形式，并通过userdata类型存储在栈中。在Lua中，C#函数被视为一种可以通过Lua调用的对象，这些对象通常会绑定在Lua栈上。以下是更详细的解释： C#函数与Lua栈的交互 C#函数封装为Lua闭包： 在XLua中，当你将C#函数暴露给Lua时，这些函数通常被包装成Lua闭包。Lua闭包是一种可以在Lua中执行的函数，它本质上是一个包含函数体和自由变量的函数。在XLua中，C#函数被转换成Lua闭包，这些闭包会被压入Lua栈中，并且可以像Lua函数一样被调用。 存储C#函数的userdata： 当C#函数传递给Lua时，XLua会将C#函数作为userdata类型存储到Lua栈中。userdata 是Lua中用来表示外部数据（如C#对象或C函数）的一个类型，因此C#函数并不会直接存储在栈中，而是存储为一个userdata，这个userdata在Lua调用时会被解封装并转化为可以执行的Lua闭包XLua框架原理(一) - 知乎。 索引和缓存： C#函数在Lua栈中并不会直接存储其索引。C#函数在XLua中的处理涉及到两部分：C#代码和Lua栈。首先，C#函数被映射到Lua中的userdata，然后通过ObjectTranslator类的机制，函数会在栈中以封装的形式出现。 当这些C#函数被第一次访问时，它们会被缓存，并在后续调用中直接通过缓存进行调用。因此，C#函数并不会每次都被重新解析，而是通过已缓存的引用快速访问。 通过元表访问C#函数： 访问C#函数时，Lua会使用元表的机制。元表中定义了如何处理userdata类型的C#函数。例如，当Lua调用一个通过XLua暴露的C#函数时，Lua栈中的userdata对象会通过元表转化为可调用的Lua闭包，从而执行对应的C#函数XLua框架原理(二) - 知乎。 总结在XLua中，C#函数在Lua栈中的存储并不是直接存储函数本身，而是通过userdata类型存储其引用。userdata是Lua与C#之间的数据桥梁，它将C#函数封装为可以通过Lua调用的形式。函数会被缓存并且通过元表进行访问，确保C#函数可以高效地在Lua中被调用。 您说：这个userdata里存储的到底是什么，是闭包还是索引？ 核实内容 我正在调查userdata字段到底是闭包还是索引，待进一步确认。这让我想到，内容的具体性质是关键。 理解userdata字段 目前正在探讨userdata字段是闭包还是索引。要充分利用这些理解，必须深入探究它们的区别和联系人。 在XLua中，userdata 存储的并不是闭包或索引，而是一个指向C#对象的引用，或者说是一个指针，用来表示C#对象或者C#函数在Lua中的表示。具体来说，userdata 存储的是一个内存地址，指向C#中的一个对象实例或方法。 userdata 在 XLua 中的作用 存储C#对象的引用： 在XLua中，userdata 主要用于存储C#对象的引用。在C#与Lua之间交互时，userdata 用来承载C#对象的地址和其他元数据。Lua中的 userdata 本质上是一个可以在Lua中使用的封装，它存储的是C#对象在内存中的位置，而不是C#对象本身。 例如，如果你在Lua中创建了一个C#的 GameObject 对象，XLua会将这个对象封装为 userdata 类型存储在Lua栈上。这些 userdata 对象会通过 ObjectTranslator 进行转换和访问。 存储C#方法的引用（封装成闭包）： 当C#函数暴露给Lua时，XLua 会将C#的函数封装为 Lua闭包，并将这些闭包存储为 userdata。Lua闭包可以被看作是一个被封装的C#函数，它可以被Lua调用。userdata 在这里存储的仍然是对C#函数的引用，而不是直接的C#函数代码。 具体来说，userdata 内部存储的是C#函数的指针，并且通过元表（metatable）来指示如何调用这个C#函数。这意味着，当Lua需要调用这个C#函数时，实际上是通过 userdata 访问C#函数的内存地址，然后通过元表的__call 方法来执行。 userdata 和闭包的关系： 当我们说 userdata 是闭包时，实际上是指 userdata 本身不是闭包，而是封装了一个C#函数的引用，这个引用被元表转换为 Lua 闭包。当Lua调用这个userdata时，元表会将其解包并执行对应的C#方法。因此，userdata 在栈中不直接存储闭包，而是通过元表机制使得 userdata 看起来像是一个闭包。 userdata 存储的内容： 具体地，userdata 存储的内容取决于它封装的对象类型。如果是C#对象，userdata 存储的是该对象在内存中的引用（或者说是C#中的指针）。如果是C#函数，userdata 存储的是C#方法的引用（函数指针）。这些信息通过ObjectTranslator进行管理和转换，使得Lua能够理解如何与这些C#对象和方法进行交互XLua框架原理(一) - 知乎XLua框架原理(二) - 知乎。 总结userdata 存储的既不是闭包，也不是索引，而是对C#对象或C#函数的引用。它本质上是一个内存地址，指向C#对象或C#方法的指针。Lua通过 userdata 访问C#对象或函数时，元表的机制使得userdata能够表现出类似闭包的行为，因此Lua可以像调用Lua函数一样调用C#函数。 您说：也就是说，Lua调用C#代码用到了一种线程通信机制？共享了一块内存？ 探讨线程通信机制 Lua调用C#代码涉及线程通信机制和共享内存。线程通信是指多个线程之间的交互，而共享内存是多个线程之间共享的数据区域，一般用于多线程程序中。这样可以同步数据访问，避免竞态条件，提高程序的效率。 深入探讨 Lua调用C#代码使用线程通信机制，并共享内存。这意味着C#和Lua之间的交互依赖于线程管理和内存共享，确保多线程程序的同步与数据一致性。 可以这么理解，但具体的机制并不是传统意义上的“线程通信”或者“共享内存”，而是一种通过内存映射和代理机制实现的跨语言调用。XLua 通过 userdata 和 元表 等机制，允许 Lua 代码调用 C# 代码，并在内存中以某种方式共享对象的引用。这种机制不涉及多线程的直接通信，而是依赖于 Lua虚拟机与C#环境之间的交互桥梁。 具体的工作原理： 内存映射与 userdata： 在 XLua 中，当 C# 对象或者方法暴露给 Lua 时，userdata 作为一种特殊的 Lua 数据类型，在 Lua 栈中保存一个指向 C# 对象或方法的 内存引用。 Lua 本身并不直接操作 C# 对象的内存，它只是通过 userdata 存储对象的引用，而 userdata 内部存储的是 C# 对象在内存中的地址。C# 对象和 Lua 之间通过 ObjectTranslator 类来完成这个转换和映射XLua框架原理(一) - 知乎XLua框架原理(二) - 知乎。 C# 与 Lua 的数据共享： 通过 userdata，Lua 可以访问 C# 中的对象和方法。虽然说是“共享内存”，但它本质上是 C#对象的引用，而不是将 C# 对象的实际内存直接映射到 Lua 中。 当 Lua 中的 userdata 被访问时，XLua 会根据其中存储的 C# 对象引用来执行相应的 C# 代码。例如，在 Lua 中调用一个通过 userdata 映射的 C# 函数时，Lua 通过元表的 __call 方法触发 C# 函数的执行。这相当于 Lua 中的“调用”通过内部映射转化为 C# 的“调用”XLua框架原理(二) - 知乎。 元表和方法代理： 元表（metatable）是 XLua 中的一个重要机制，它用来定义如何访问和操作 userdata。当 Lua 中访问一个 userdata 对象时，实际上是通过元表来代理这些操作的。元表定义了在 Lua 中访问 userdata 对象时应该如何去查找和执行 C# 中的对应方法XLua框架原理(一) - 知乎。 比如，当 Lua 代码调用 CS.UnityEngine.GameObject() 创建一个 C# 的 GameObject 对象时，XLua 会为这个 C# 对象创建一个 userdata，并将该对象的引用传递给 Lua。Lua 中对该对象的访问通过元表的 __index 和 __newindex 方法来转发到 C# 对象的实际方法和属性。 对象生命周期管理： 对象的生命周期也是通过这种机制管理的。userdata 是一种弱引用，意味着当 Lua 中的 userdata 对象不再被引用时，Lua 的垃圾回收器会自动清理这些对象，并触发 C# 端的 __gc 回调，从而释放 C# 端的资源XLua框架原理(二) - 知乎。 总结：XLua 使用的并不是传统的“线程通信”或“共享内存”，而是一种 内存引用的传递 机制，通过 userdata 类型封装 C# 对象的引用，并通过元表来实现 Lua 与 C# 之间的交互。Lua 中的 userdata 只是一个对 C# 对象或方法的引用，而不直接涉及内存共享或线程通信。 HotFix加特性 在设置里加入宏 HotFix注入，替换C#函数的逻辑","link":"/HexoBlog/2025/05/04/Lua/XLua/"},{"title":"帧同步学习：网络库（一）","text":"对于网络连接有这样几个抽象： NetBase，是一个非托管的封装 NetworkProxy， Server 用来管理服务器的网络状态 在这个之中， 网络连接的维护是有三个相关的类 首先是NetworkProxy通过AService管理网络状态。然后具体的链接的抽象是AChannel 在AChannel的上层还有一级抽象，Session 发送消息最后是通过Session维护的Channel来发送的。而报文的装填和管理实在Session里处理的 1234567[应用层] - 业务逻辑层 |[会话层] - Session (会话管理) |[传输层] - AChannel (通道层) |[网络层] - Socket/Network 1234567891011121314151617[应用层] - 业务逻辑 | |-- 发送业务消息 |[会话层] - Session |-- 序列化消息 |-- 管理请求响应 |-- 分发消息 |[传输层] - AChannel |-- 数据分片 |-- 可靠传输 |-- 错误处理 | - TCP/UDP |-- 数据包传输 |-- 连接管理 服务器流程 ServerLauncher启动一个Server 123456public class ServerLauncher { static void DoAwake(){ server = new Server(); server.Start(); }} Server负责处理消息传递过来之后的回调，他是一个IMessageDispatcher，和新方法是： 1234567891011121314151617181920212223public void Dispatch(Session session, Packet packet){ ushort opcode = packet.Opcode(); var message = session.Network.MessagePacker.DeserializeFrom(opcode, packet.Bytes, Packet.Index, packet.Length - Packet.Index) as IMessage; //var msg = JsonUtil.ToJson(message); //Log.sLog(&quot;Server &quot; + msg); var type = (EMsgType) opcode; switch (type) { case EMsgType.JoinRoom: OnPlayerConnect(session, message); break; case EMsgType.QuitRoom: OnPlayerQuit(session, message); break; case EMsgType.PlayerInput: OnPlayerInput(session, message); break; case EMsgType.HashCode: OnPlayerHashCode(session, message); break; } } 这里我们看的是初始化启动的时候，Server会完成对NetProxy的初始化： 12345678//Server.csprivate NetOuterProxy _netProxy = new NetOuterProxy(); public void Start(){ _netProxy.MessageDispatcher = this; _netProxy.MessagePacker = MessagePacker.Instance; _netProxy.Awake(NetworkProtocol.TCP, serverIpPoint); _startUpTimeStamp = _lastUpdateTimeStamp = DateTime.Now; } NetOuterProxy是NetProxy的子类，我们看NetProxy的行为： 12345678910111213141516171819202122232425public abstract class NetworkProxy : NetBase { private AService Service; private readonly Dictionary&lt;long, Session&gt; sessions = new Dictionary&lt;long, Session&gt;(); public IMessagePacker MessagePacker { get; set; } public IMessageDispatcher MessageDispatcher { get; set; } public void Awake(NetworkProtocol protocol, IPEndPoint ipEndPoint){ try { switch (protocol) { case NetworkProtocol.TCP: this.Service = new TService(ipEndPoint); break; default: throw new ArgumentOutOfRangeException(); } this.StartAccept(); } catch (Exception e) { throw new Exception($&quot;{ipEndPoint}&quot;, e); } } 可以看到它实际上是创建了一个Service对象，然后调用自身的NetworkProxyStartAccept() Service对象初始化的时候，完成了对于TcpListener的初始化 123456789class Service{ private TcpListener acceptor; public TService(IPEndPoint ipEndPoint){ this.acceptor = new TcpListener(ipEndPoint); this.acceptor.Server.SetSocketOption(SocketOptionLevel.Socket, SocketOptionName.ReuseAddress, true); this.acceptor.Server.NoDelay = true; this.acceptor.Start(); } StartAccept会不断的调用Accept函数 12345678910111213141516171819// NetworkProxy.cs private async void StartAccept(){ while (true) { if (this.IsDisposed) { return; } await this.Accept(); } } public virtual async Task&lt;Session&gt; Accept(){ AChannel channel = await this.Service.AcceptChannel(); Session session = CreateSession(this, channel); channel.ErrorCallback += (c, e) =&gt; { this.Remove(session.Id); }; this.sessions.Add(session.Id, session); session.Start(); return session; } NetworkProxy的Accept函数，实际上会建立一个和Client的Channel（借助Service） Service是TcpListener的封装，并且管理了它建立的Channel,Service是Socket最直接的抽象封装 1234567891011121314151617class Service{ private TcpListener acceptor;private readonly Dictionary&lt;long, TChannel&gt; idChannels = new Dictionary&lt;long, TChannel&gt;(); public override async Task&lt;AChannel&gt; AcceptChannel(){ if (this.acceptor == null) { throw new Exception(&quot;service construct must use host and port param&quot;); } TcpClient tcpClient = await this.acceptor.AcceptTcpClientAsync(); TChannel channel = new TChannel(tcpClient, this); this.idChannels[channel.Id] = channel; return channel; } 在这里实际上是建立起了TCP的通道 在Channel的基础上，创建Session的抽象，这个实际上是会话层的概念，Session提供了从通道中获取数据的方法，而NetworkProxy则是提供了Session的方法的调用的位置 123456class NetworkProxy{ public static Session CreateSession(NetworkProxy net, AChannel c){ Session session = new Session {Id = IdGenerater.GenerateId()}; session.Awake(net, c); return session; } Session的Start会开始接受数据： 1234567891011121314151617181920212223public sealed class Session : NetBase { private static int RpcId { get; set; } private AChannel channel; private readonly Dictionary&lt;int, Action&lt;IResponse&gt;&gt; requestCallback = new Dictionary&lt;int, Action&lt;IResponse&gt;&gt;(); private readonly List&lt;byte[]&gt; byteses = new List&lt;byte[]&gt;() {new byte[1], new byte[0], new byte[0]}; public NetworkProxy Network; public object BindInfo; public T GetBindInfo&lt;T&gt;() where T : class{ return BindInfo as T; } public void Awake(NetworkProxy net, AChannel c){ this.Network = net; this.channel = c; this.requestCallback.Clear(); } public void Start(){ this.StartRecv(); } StartRecv里也是一个循环：也就是说，只要Session不被释放，就会不断的异步的从Channel里拿数据 12345678910111213141516171819202122232425262728public sealed class Session : NetBase { private async void StartRecv(){ while (true) { if (this.IsDisposed) { return; } Packet packet; try { packet = await this.channel.Recv(); if (this.IsDisposed) { return; } } catch (Exception e) { Log.Error(e.ToString()); continue; } try { this.Run(packet); } catch (Exception e) { Log.Error(e.ToString()); } } } 具体拿数据的操作是channel的Recv方法： 12345678910111213141516171819// TChannelclass TChannel{ public override Task&lt;Packet&gt; Recv() { if (this.IsDisposed) { throw new Exception(&quot;TChannel已经被Dispose, 不能接收消息&quot;); } bool isOK = this.parser.Parse(); if (isOK) { Packet packet = this.parser.GetPacket(); return Task.FromResult(packet); } recvTcs = new TaskCompletionSource&lt;Packet&gt;(); return recvTcs.Task; } 可以看到，这里拿到的数据实际上是从parser里拿到的，这个parser实际上是一个PacketParser 梳理1：到目前为止的流程是，服务器Server启动的时候，会创建一个代理（NetWorkProxy），然后这个代理里面管理着一个Socket的封装也就是TService，然后TService会使用Socket，借助TcpListener创建TcpClinet。 这个TcpClinet被封装为Channel，Channel与客户端建立联系。在Channel上还有一层封装Session（为了实现什么呢？可靠？还是啥），提供了Rev的接口。 在NetWorkProxy的StartAccept函数当中，会有一个循环，不断的调用Accept，建立Channel，然后获取session。而await AcceptChannel()是u异步的，所以如果没有链接的，就会导致当前这部分挂起，知道有客户端链接为止。 在TChannel里面的哪个Recv方法，里面也有一个循环，也是一样的，保证是一个Channel可以一直获取数据。而NetWorkProxy那边则是保证了可以多次反复的链接到服务器 这里我们自然就好奇，这个parser到底是咋被填入的东西对吧 而实际上，PacketParser在TChannel构造的时候，直接获取了一个recvBuffer的引用 12345678910111213141516171819202122232425262728public class TChannel : AChannel { private readonly TcpClient tcpClient; private readonly CircularBuffer recvBuffer = new CircularBuffer(); /// &lt;summary&gt; /// connect /// &lt;/summary&gt; public TChannel(TcpClient tcpClient, IPEndPoint ipEndPoint, TService service) : base(service, ChannelType.Connect) { this.tcpClient = tcpClient; this.parser = new PacketParser(this.recvBuffer); this.RemoteAddress = ipEndPoint; this.ConnectAsync(ipEndPoint); } /// &lt;summary&gt; /// accept /// &lt;/summary&gt; public TChannel(TcpClient tcpClient, TService service) : base(service, ChannelType.Accept) { this.tcpClient = tcpClient; this.parser = new PacketParser(this.recvBuffer);//&lt;--这里 IPEndPoint ipEndPoint = (IPEndPoint)this.tcpClient.Client.RemoteEndPoint; this.RemoteAddress = ipEndPoint; this.OnAccepted(); } 也因此，在PacketParser当中就是直接用这个引用来处理的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960internal class PacketParser{ private readonly CircularBuffer buffer; private ushort packetSize; private ParserState state; private Packet packet = new Packet(ushort.MaxValue); private bool isOK; public PacketParser(CircularBuffer buffer) { this.buffer = buffer; } public bool Parse() { if (this.isOK) { return true; } bool finish = false; while (!finish) { switch (this.state) { case ParserState.PacketSize: if (this.buffer.Length &lt; 2) { finish = true; } else { this.buffer.Read(this.packet.Bytes, 0, 2); this.packetSize = BytesHelper.ToUInt16(this.packet.Bytes, 0); if (packetSize &gt; 60000) { throw new Exception($&quot;packet too large, size: {this.packetSize}&quot;); } this.state = ParserState.PacketBody; } break; case ParserState.PacketBody: if (this.buffer.Length &lt; this.packetSize) { finish = true; } else { this.buffer.Read(this.packet.Bytes, 0, this.packetSize); this.packet.Length = this.packetSize; this.isOK = true; this.state = ParserState.PacketSize; finish = true; } break; } } return this.isOK; } NetWorkProxy的MessageDispatcherServer和Client都实现了IMessageDispatcher这个接口，这个接口要求提供Dispatch方法的实现。 而这个这个接口被NetworkProxy的MessageDispatcher字段管理，都在Start的时候被赋值 1234567//Server public void Start(){ _netProxy.MessageDispatcher = this; _netProxy.MessagePacker = MessagePacker.Instance; _netProxy.Awake(NetworkProtocol.TCP, serverIpPoint); _startUpTimeStamp = _lastUpdateTimeStamp = DateTime.Now; } 这个Dispatch方法什么时候被调用呢，就是在Session的StartRev当中的Run方法里 12345678910111213141516// Session private void Run(Packet packet){ if (packet.Length &lt; Packet.MinSize) { Log.Error($&quot;message error length &lt; {Packet.MinSize}, ip: {this.RemoteAddress}&quot;); this.Network.Remove(this.Id); return; } byte flag = packet.Flag(); ushort opcode = packet.Opcode();#if !SERVER if (OpcodeHelper.IsClientHotfixMessage(opcode)) { this.Network.MessageDispatcher.Dispatch(this, packet); //&lt;- 这里 return; } (this.buffer.Length &lt; 2) { finish = true; } else { this.buffer.Read(this.packet.Bytes, 0, 2); this.packetSize = BytesHelper.ToUInt16(this.packet.Bytes, 0); if (packetSize &gt; 60000) { throw new Exception($”packet too large, size: {this.packetSize}”); } this.state = ParserState.PacketBody; } break; case ParserState.PacketBody: if (this.buffer.Length &lt; this.packetSize) { finish = true; } else { this.buffer.Read(this.packet.Bytes, 0, this.packetSize); this.packet.Length = this.packetSize; this.isOK = true; this.state = ParserState.PacketSize; finish = true; } break; } } return this.isOK; }","link":"/HexoBlog/2025/05/08/%E5%B8%A7%E5%90%8C%E6%AD%A5/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E7%BD%91%E7%BB%9C%E5%BA%93/"},{"title":"帧同步学习：客户端通信（二）","text":"帧同步学习：客户端通信（二）客户端这边，GameManager在启动的时候会初始化一个NetClient 它是一个public class NetClient : IMessageDispatcher 与上一个Server一样 123456789101112131415161718192021public class NetClient : IMessageDispatcher { public static IPEndPoint serverIpPoint = NetworkUtil.ToIPEndPoint(&quot;127.0.0.1&quot;, 10083); private NetOuterProxy net = new NetOuterProxy(); public Session Session; private int count = 0; public int id; public void Dispatch(Session session, Packet packet){ ushort opcode = packet.Opcode(); var message = session.Network.MessagePacker.DeserializeFrom(opcode, packet.Bytes, Packet.Index, packet.Length - Packet.Index) as IMessage; var type = (EMsgType) opcode; switch (type) { case EMsgType.FrameInput: OnFrameInput(session, message); break; case EMsgType.StartGame: OnStartGame(session, message); break; } } 而在GameManager的Start生命周期函数调用的时候 123456789101112131415161718//GameManager private void _Start(){ DoStart(); foreach (var mgr in _mgrs) { mgr.DoStart(); } Debug.Trace(&quot;Before StartGame _IdCounter&quot; + BaseEntity.IdCounter); if (!IsReplay &amp;&amp; !IsClientMode) { netClient = new NetClient(); //《--初始化 netClient.Start(); netClient.Send(new Msg_JoinRoom() {name = Application.dataPath}); //传过去一个加入房间的事件 } else { StartGame(0, playerServerInfos, localPlayerId); } } 之后在DoUpdate函数当中，定时会传输SendInput到服务器， 123456789101112131415161718private void _DoUpdate(){ if (!_hasStart) return; remainTime += Time.deltaTime; while (remainTime &gt;= 0.03f) { remainTime -= 0.03f; //send input if (!IsReplay) { SendInput(); //《===这里 } if (GetFrame(curFrameIdx) == null) { return; } Step(); }} 这里我们先不关心帧同步的那部分，先看信息传输： 123456789101112131415161718192021222324public void SendInput(){ if (IsClientMode) { PushFrameInput(new FrameInput() { tick = curFrameIdx, inputs = new PlayerInput[] {CurGameInput} }); return; } predictTickCount = 2; //Mathf.Clamp(Mathf.CeilToInt(pingVal / 30), 1, 20); if (inputTick &gt; predictTickCount + _maxServerFrameIdx) { return; } var playerInput = CurGameInput; netClient?.Send(new Msg_PlayerInput() { // &lt;==看这里 input = playerInput, tick = inputTick }); //UnityEngine.Debug.Log(&quot;&quot; + playerInput.inputUV); tick2SendTimer[inputTick] = Time.realtimeSinceStartup; //UnityEngine.Debug.Log(&quot;SendInput &quot; + inputTick); inputTick++;} 所以，客户端传输信息就很明确了","link":"/HexoBlog/2025/05/10/%E5%B8%A7%E5%90%8C%E6%AD%A5/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%80%9A%E4%BF%A1/"},{"title":"帧同步学习：CS的设计","text":"服务器的设计是这样的一个思路： 初始化TcpListener包括了创建Socket对象 等待注册首先服务器启动注册和等待流程，然后等待用户注册的流程 也就是通过监听端口，监听创建试图连接到服务器的客户端 1234567891011121314151617181920212223242526272829303132333435//NetworkProxypublic void Awake(NetworkProtocol protocol, IPEndPoint ipEndPoint){ try { switch (protocol) { case NetworkProtocol.TCP: this.Service = new TService(ipEndPoint); break; default: throw new ArgumentOutOfRangeException(); } this.StartAccept(); //&lt;--注意这个 } catch (Exception e) { throw new Exception($&quot;{ipEndPoint}&quot;, e); }}//他会不断的循环，检查客户端对于服务器链接的请求private async void StartAccept(){ while (true) { //&lt;--注意这个循环 if (this.IsDisposed) { return; } await this.Accept(); }}public virtual async Task&lt;Session&gt; Accept(){ AChannel channel = await this.Service.AcceptChannel(); //&lt;--注意这个挂起 Session session = CreateSession(this, channel); channel.ErrorCallback += (c, e) =&gt; { this.Remove(session.Id); }; this.sessions.Add(session.Id, session); session.Start(); return session;} 开始更新（服务器）服务器会不断的接受来自客户端的消息 123456while (true) { try { Thread.Sleep(3); contex.Update(); server.Update(); } Server.cs，定时，Server会在到达一定时间之后，尝试去做DoUpdate 123456789101112131415public void Update(){ var now = DateTime.Now; _deltaTime = (now - _lastUpdateTimeStamp).TotalSeconds; if (_deltaTime &gt; UpdateInterval) { _lastUpdateTimeStamp = now; _timeSinceStartUp = (now - _startUpTimeStamp).TotalSeconds; DoUpdate(); }}public void DoUpdate(){ //check frame inputs var fDeltaTime = (float) _deltaTime; var fTimeSinceStartUp = (float) _timeSinceStartUp; _room?.DoUpdate(fTimeSinceStartUp, fDeltaTime);} 而在Room当中的DoUpdate会尝试取到所有的客户端发来的输入消息，然后广播 1234567891011121314151617181920212223242526//Room.cs public void DoUpdate(float timeSinceStartUp, float deltaTime){ if (!IsRunning) return; CheckInput(); } private void CheckInput(){ if (_tick2Inputs.TryGetValue(_curTick, out var inputs)) { if (inputs != null) { bool isFullInput = true; for (int i = 0; i &lt; inputs.Length; i++) { if (inputs[i] == null) { isFullInput = false; break; } } if (isFullInput) { //&lt;--这里会有一个问题，就是如果客户端没有全部发来消息，如何处理（通过预测+回滚） BoardInputMsg(_curTick, inputs); _tick2Inputs.Remove(_curTick); _curTick++; } } } } 我们这里要先关心，_tick2Inputs这个存储所有用户输入的Dictionary是如何更新的private Dictionary&lt;int, PlayerInput[]&gt; _tick2Inputs = new Dictionary&lt;int, PlayerInput[]&gt;(); 注意这个dic的Key是tick，也就是当前帧，value是当前帧，所有用户传过来的输入（这里的问题是，如何保证客户端和服务器帧同步） 他是在这个函数回调： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//Room.cs public void OnPlayerInput(int useId, Msg_PlayerInput msg){ //Debug.Log($&quot; Recv Input: {useId} {msg.input.inputUV}&quot;); int localId = 0; if (!_id2LocalId.TryGetValue(useId, out localId)) return; PlayerInput[] inputs; if (!_tick2Inputs.TryGetValue(msg.tick, out inputs)) { inputs = new PlayerInput[MaxPlayerCount]; _tick2Inputs.Add(msg.tick, inputs); } inputs[localId] = msg.input; CheckInput(); }//而这个OnPlayerInput最终是在Dispatch当中调用的：//Server.csvoid OnPlayerInput(Session session, IMessage message){ var msg = message as Msg_PlayerInput; var player = session.GetBindInfo&lt;PlayerServerInfo&gt;(); _room?.OnPlayerInput(player.Id, msg); }public void Dispatch(Session session, Packet packet){ ushort opcode = packet.Opcode(); var message = session.Network.MessagePacker.DeserializeFrom(opcode, packet.Bytes, Packet.Index, packet.Length - Packet.Index) as IMessage; //var msg = JsonUtil.ToJson(message); //Log.sLog(&quot;Server &quot; + msg); var type = (EMsgType) opcode; switch (type) { case EMsgType.JoinRoom: OnPlayerConnect(session, message); break; case EMsgType.QuitRoom: OnPlayerQuit(session, message); break; case EMsgType.PlayerInput: OnPlayerInput(session, message); break; case EMsgType.HashCode: OnPlayerHashCode(session, message); break; }} 那么这个Server的Dispatch是在哪里调用的呢？ 其实是在上面建立的TChannel，再通过TChannel建立的Session那边调用的： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//Session public void Start(){ this.StartRecv(); } private async void StartRecv(){ while (true) { if (this.IsDisposed) { return; } Packet packet; try { packet = await this.channel.Recv(); //&lt;--如果客户端有东西发过来 if (this.IsDisposed) { return; } } catch (Exception e) { Log.Error(e.ToString()); continue; } try { this.Run(packet); //&lt;--就调用Run } catch (Exception e) { Log.Error(e.ToString()); } } } private void Run(Packet packet){ if (packet.Length &lt; Packet.MinSize) { Log.Error($&quot;message error length &lt; {Packet.MinSize}, ip: {this.RemoteAddress}&quot;); this.Network.Remove(this.Id); return; } byte flag = packet.Flag(); ushort opcode = packet.Opcode(); if (OpcodeHelper.IsClientHotfixMessage(opcode)) { this.Network.MessageDispatcher.Dispatch(this, packet); //&lt;--这里就是Server，因为Server实现了IMessageDispatcher接口 return; } //... } 这个调用链是： Server在Awake的时候，在StartAccept开启了轮询，接受客户端链接，每有一个客户端完成链接，就会建立起一个TChannel，并且建立一个Session 而后，session的Start函数会被调用，这个函数会调用到StartRecv，而StartRecv会不断的检查来自客户端的发送，如果客户端有东西发过来，就调用Run，最后调用到Server的Dispatch当中，并且根据发送过来消息的类型，调用对应的回调函数。 比如如果是输入调用，当检查完所有的客户端都发过来了，那就广播，并且服务器定时也会检查输入（也就是在Room.DoUpdate当中）","link":"/HexoBlog/2025/05/10/%E5%B8%A7%E5%90%8C%E6%AD%A5/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%EF%BC%9ACS%E7%9A%84%E8%AE%BE%E8%AE%A1/"},{"title":"","text":"基于我收集到的信息，我现在可以回答您关于LockStep网络库中Session抽象的问题了。 LockStep网络库中Session抽象的作用与实现Session抽象的目的在LockStep网络库中，Session是一个核心抽象，主要用于以下几个目的： 连接管理：Session代表一个网络连接会话，封装了与远程端点的通信细节。它管理TCP连接的生命周期，从建立到断开。 可靠性保证：Session实现了可靠的消息传输机制，特别是在帧同步游戏中至关重要的可靠性保证。它处理消息的发送、接收、错误处理和重连逻辑。 RPC（远程过程调用）支持：Session提供了Call方法实现请求-响应模式的通信，支持异步RPC调用，使网络通信更加结构化。 消息分发：Session负责接收网络消息并通过MessageDispatcher分发到相应的处理逻辑。 错误处理：Session实现了错误检测和处理机制，当网络连接出现问题时能够及时通知上层应用。 Session在框架中的具体实现从代码中可以看到，Session的实现包含以下关键部分： 1. 连接管理1234567891011121314151617181920212223242526272829public sealed class Session : NetBase { private AChannel channel; public NetworkProxy Network; public void Awake(NetworkProxy net, AChannel c){​ this.Network = net;​ this.channel = c;​ this.requestCallback.Clear(); } public void Start(){​ this.StartRecv(); }} Session封装了底层的通信通道(AChannel)，提供了更高级的抽象。NetworkProxy负责创建和管理Session，而Session则负责与远程端点的实际通信。 2. 可靠性机制Session实现了可靠的消息传输机制： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private async void StartRecv(){ while (true) {​ if (this.IsDisposed) {​ return;​ }​ Packet packet;​ try {​ packet = await this.channel.Recv();​ if (this.IsDisposed) {​ return;​ }​ }​ catch (Exception e) {​ Log.Error(e.ToString());​ continue;​ }​ try {​ this.Run(packet);​ }​ catch (Exception e) {​ Log.Error(e.ToString());​ } }} 这个循环不断地接收消息，即使发生异常也会继续尝试，提供了持续的连接可靠性。 3. RPC实现Session提供了异步RPC调用机制： 12345678910111213141516171819202122232425262728293031323334353637public Task&lt;IResponse&gt; Call(IRequest request){ int rpcId = ++RpcId; var tcs = new TaskCompletionSource&lt;IResponse&gt;(); this.requestCallback[rpcId] = (response) =&gt; {​ try {​ if (response.Error &gt; ErrorCode.ERR_Exception) {​ throw new RpcException(response.Error, response.Message);​ }​ tcs.SetResult(response);​ }​ catch (Exception e) {​ tcs.SetException(new Exception($&quot;Rpc Error: {request.GetType().FullName}&quot;, e));​ } }; request.RpcId = rpcId; this.Send(0x00, request); return tcs.Task;} 这个实现使用TaskCompletionSource来支持异步编程模型，允许上层代码使用async/await进行RPC调用。 4. 消息分发1234567891011121314151617181920212223private void Run(Packet packet){ // ... // flag第一位为1表示这是rpc返回消息,否则交由MessageDispatcher分发 if ((flag &amp; 0x01) == 0) {​ this.Network.MessageDispatcher.Dispatch(this, packet);​ return; } // 处理RPC响应 // ...} Session根据消息标志决定是处理RPC响应还是将消息分发给MessageDispatcher。 5. 错误处理123456789101112131415161718192021222324252627public override void Dispose(){ if (this.IsDisposed) {​ return; } long id = this.Id; base.Dispose(); foreach (Action&lt;IResponse&gt; action in this.requestCallback.Values.ToArray()) {​ action.Invoke(new ResponseMessage {Error = ErrorCode.ERR_SocketDisconnected}); } this.channel.Dispose(); this.Network.Remove(id); this.requestCallback.Clear();} 当Session被销毁时，它会通知所有等待中的RPC调用连接已断开，确保上层应用能够处理连接中断的情况。 Session在帧同步中的重要性在帧同步游戏中，Session抽象尤为重要： 确保输入同步：帧同步要求所有玩家在同一帧接收到相同的输入，Session的可靠传输机制确保了输入指令能够可靠地传递。 处理网络延迟：通过NetworkDefine中定义的延迟常量和Session的实现，框架能够处理网络延迟问题，确保游戏状态的一致性。 支持断线重连：Session的设计允许检测连接断开并支持重新连接，这对于长时间运行的游戏会话至关重要。 总结LockStep网络库中的Session抽象是为了实现可靠的网络通信而设计的，它不仅提供了基本的连接管理功能，还实现了RPC调用、消息分发和错误处理等高级特性。在帧同步游戏中，Session的可靠性保证是确保所有玩家游戏状态一致的关键因素。 Session的设计体现了关注点分离的原则：NetworkProxy负责管理多个Session，而每个Session则专注于与单个远程端点的通信。这种分层设计使得网络库更加模块化和可维护。","link":"/HexoBlog/2025/05/16/%E5%B8%A7%E5%90%8C%E6%AD%A5/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%EF%BC%9ASession/"},{"title":"帧同步学习：异常处理","text":"在这个框架中，帧同步的时候客户端没有及时传输数据到客户端的时候，模型是如何处理的基于我收集到的信息，我现在可以回答您关于LockStep框架中客户端未及时接收到数据时的处理机制： LockStep框架中客户端未及时接收到数据的处理机制在LockStep帧同步框架中，当客户端未能及时接收到其他客户端的输入数据时，框架采用了一系列机制来确保游戏的连续性和一致性。以下是该框架处理这种情况的关键机制： 1. 延迟容忍机制框架在NetworkDefine.cs中定义了几个关键的延迟常量： 12345678/// 最大延迟时间 超过这个时间 依旧等不到玩家的输入包，默认玩家没有输入（输入丢失）public const int MAX_DELAY_TIME_MS = 300;/// 正常玩家的延迟public const int NORMAL_PLAYER_MAX_DELAY = 100;/// 正常玩家最大收到输入确认包的延迟 （有其中一个玩家输入延迟太大 且自身网络达到66%丢包率 情况下的时延）public const int MAX_FRAME_DATA_DELAY = MAX_DELAY_TIME_MS + NORMAL_PLAYER_MAX_DELAY + 2 * UPDATE_DELTATIME; 这些常量定义了框架对网络延迟的容忍度。当某个客户端的输入数据延迟超过MAX_DELAY_TIME_MS（300毫秒）时，框架会认为该输入已丢失，并采取相应措施。 2. 空帧填充机制当某一帧的输入数据未及时到达时，框架会创建一个空的FrameInput对象来填充缺失的帧： 12345678910public static void PushFrameInput(FrameInput input){ var frames = Instance.frames; for (int i = frames.Count; i &lt;= input.tick; i++) { frames.Add(new FrameInput()); // 创建空帧 } // ... frames[input.tick] = input; // 用实际收到的输入替换对应帧位置} 这确保了即使某些帧的输入数据缺失，游戏逻辑仍然可以继续执行，不会因为等待输入而卡住。 3. 预测帧机制框架实现了预测帧机制，允许客户端在一定程度上预测未来的帧： 12345678public void SendInput(){ // ... predictTickCount = 2; //Mathf.Clamp(Mathf.CeilToInt(pingVal / 30), 1, 20); if (inputTick &gt; predictTickCount + _maxServerFrameIdx) { return; } // ...} predictTickCount变量控制客户端可以预测的帧数（默认为2帧）。这允许客户端在一定程度上”超前”于已确认的服务器帧，减少网络延迟对游戏体验的影响。 4. 帧等待机制在GameManager的_DoUpdate方法中，当当前帧的输入数据不可用时，游戏会暂停更新： 1234567891011121314151617private void _DoUpdate(){ if (!_hasStart) return; remainTime += Time.deltaTime; while (remainTime &gt;= 0.03f) { remainTime -= 0.03f; //send input if (!IsReplay) { SendInput(); } if (GetFrame(curFrameIdx) == null) { return; // 如果当前帧的输入数据不可用，则暂停更新 } Step(); }} 这确保了游戏只会在有输入数据的情况下前进，保持所有客户端的同步。 5. 哈希校验机制为了确保所有客户端的游戏状态一致，框架实现了哈希校验机制： 1234567891011121314151617181920private void Step(){ // ... //send hash netClient?.Send(new Msg_HashCode() { tick = curFrameIdx, hash = GetHash() }); // ...}public int GetHash(){ int hash = 1; int idx = 0; foreach (var entity in allPlayers) { hash += entity.currentHealth.GetHash() * PrimerLUT.GetPrimer(idx++); hash += entity.transform.GetHash() * PrimerLUT.GetPrimer(idx++); } // ... return hash;} 每个客户端在每一帧结束后都会计算当前游戏状态的哈希值并发送给服务器。服务器可以比较所有客户端的哈希值，如果发现不一致，可以采取措施（如回滚或重新同步）。 6. 延迟监控框架会记录每一帧的延迟情况，用于监控网络性能： 1234567public static void PushFrameInput(FrameInput input){ // ... if (Instance.tick2SendTimer.TryGetValue(input.tick, out var val)) { Delays.Add(Time.realtimeSinceStartup - val); } // ...} 这些延迟数据可以用于调整预测帧数或其他网络参数，优化游戏体验。 总结LockStep框架通过以下机制处理客户端未及时接收到数据的情况： 延迟容忍：设定最大延迟时间阈值，超过阈值则认为输入丢失 空帧填充：为缺失的帧创建空的输入数据，确保游戏逻辑继续执行 预测帧：允许客户端预测未来几帧，减少网络延迟的影响 帧等待：当关键帧数据缺失时暂停游戏更新，确保同步 哈希校验：通过比较游戏状态哈希值确保所有客户端状态一致 延迟监控：记录和分析网络延迟数据，优化游戏体验 这些机制共同确保了即使在网络条件不佳的情况下，LockStep帧同步系统仍能保持游戏的一致性和流畅性。 HashCode校验为了保证各个客户端状态正确，因此在客户端的GameManager当中，完成Step（更新）之后，就会吧当前的帧的状态计算一个HashCode然后发给服务器 123456789101112131415161718192021222324252627282930313233343536//GameManager.cs private void Step(){ UpdateFrameInput(); if (IsReplay) { if (curFrameIdx &lt; frames.Count) { Replay(curFrameIdx); curFrameIdx++; } } else { Recoder(); //send hash netClient?.Send(new Msg_HashCode() { tick = curFrameIdx, hash = GetHash() }); TraceHelper.TraceFrameState(); curFrameIdx++; } }public int GetHash(){ int hash = 1; int idx = 0; foreach (var entity in allPlayers) { hash += entity.currentHealth.GetHash() * PrimerLUT.GetPrimer(idx++); hash += entity.transform.GetHash() * PrimerLUT.GetPrimer(idx++); } foreach (var entity in EnemyManager.Instance.allEnemy) { hash += entity.currentHealth.GetHash() * PrimerLUT.GetPrimer(idx++); hash += entity.transform.GetHash() * PrimerLUT.GetPrimer(idx++); } return hash; }","link":"/HexoBlog/2025/05/10/%E5%B8%A7%E5%90%8C%E6%AD%A5/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"},{"title":"","text":"帧同步学习：数学库帧同步基于这样的原则：我们的服务器用于转发“操作”，而客户端完成对于服务器转发来操作的具体操作。 那么我们显然需要保证各个客户端对于相同的”操作“都有完全一致的结果。 但是由于不同平台对于浮点数存储的舍入的不同，即使是相同输入也会带来不同的可能的结果。所以通过其他方式来替代浮点数就有很重要的意义了。 从思路上我们有两种思路： 整数 定点数 实际上定点数也是一种整数，从实现上他其实是通过整数+缩放来实现的。 定点数相对于整数的优势其实是在于：整数的精度太低了。 比如我们要获取一个输入轴的输入：0.5 那么对于整数，要么舍入到0要么到1。 而定点数则是可以规定一个定点精度，比如3位精度，那么就需要将0.5*1000然后存储为一个整数","link":"/HexoBlog/2025/05/16/%E5%B8%A7%E5%90%8C%E6%AD%A5/%E5%B8%A7%E5%90%8C%E6%AD%A5%E5%AD%A6%E4%B9%A0%EF%BC%9A%E6%95%B0%E5%AD%A6%E5%BA%93/"}],"tags":[{"name":"Lua,XLua","slug":"Lua-XLua","link":"/HexoBlog/tags/Lua-XLua/"},{"name":"Lua","slug":"Lua","link":"/HexoBlog/tags/Lua/"},{"name":"LockStep, Web","slug":"LockStep-Web","link":"/HexoBlog/tags/LockStep-Web/"}],"categories":[],"pages":[]}